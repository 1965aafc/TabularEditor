<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="System.Collections.Specialized" #>
<#+

class Rules {
	public static bool IsTranslatable(Type t, bool includeAncestors = false) {
		switch(t.Name) {
			case "Model":
			case "ModelRole":
			case "Perspective":
			case "Table":
			case "Level":
			case "Column":
			case "Hierarchy":
			case "Measure":
				return true;
			default:
				return includeAncestors && t.IsSubclassOf(typeof(MetadataObject)) ? IsTranslatable(t.BaseType, true) : false;
        }
    }

	public static bool IsPerspectiveObject(Type t, bool includeAncestors = false) {
		switch(t.Name) {
			case "Table":
			case "Column":
			case "Hierarchy":
			case "Measure":
				return true;
			default:
				return includeAncestors && t.IsSubclassOf(typeof(MetadataObject)) ? IsPerspectiveObject(t.BaseType, true) : false;
        }
    }

	public static bool HasDisplayFolder(Type t) {
		return t.GetMember("DisplayFolder").Length >= 1;
    }

	public static void CreateConstructor(StringBuilder codeOutput) {

    }

	public static bool ShouldWrapProperty(PropertyInfo p, Type t)
    {
		return p.Name != "Name" && (
				Aliases.ContainsKey(p.PropertyType) ||
				(p.Name != "Table" && p.PropertyType.IsClass && ObjectTypes.ContainsKey(p.PropertyType)) ||
				(p.Name != "ObjectType" && p.PropertyType.IsEnum)
			);
    }

	public static bool ShouldWrapCollectionProperty(PropertyInfo p, Type t)
    {
		if(t == typeof(Level)) {
			switch(p.Name) {
				case "Ordinal":
				case "Column":
					return false;
            }
        }

		return p.Name != "Name" && (
				Aliases.ContainsKey(p.PropertyType) ||
				(p.Name != "Table" && p.PropertyType.IsClass && ObjectTypes.ContainsKey(p.PropertyType)) ||
				(p.Name != "ObjectType" && p.PropertyType.IsEnum)
			) &&
			p.SetMethod != null && p.SetMethod.IsPublic;
    }

	public static string PropertyType(PropertyInfo p)
    {
		if(Aliases.ContainsKey(p.PropertyType)) return Aliases[p.PropertyType];
		if (p.PropertyType.IsEnum) return "TOM." + p.PropertyType.Name;
		return p.PropertyType.Name;
    }

	public static string PropertySetter(PropertyInfo p)
    {
		if (p.SetMethod == null || !p.SetMethod.IsPublic) return "";

		string resolveObject = "value";
		if(p.PropertyType.IsClass && p.PropertyType != typeof(string)) {
			switch(p.Name) {
				case "SortByColumn":
					resolveObject = "value == null ? null : Table.Columns[value.MetadataObject.Name].MetadataObject";
					break;
				case "DefaultColumn":
				case "DefaultHierarchy":
				case "Relationship":
					resolveObject = "value == null ? null : value.MetadataObject";
					break;
				case "Column":
					resolveObject = "value == null ? null : Hierarchy.Table.Columns[value.MetadataObject.Name].MetadataObject";
					break;

					// TODO: Fix this, so we can properly resolve below properties in case of deletions
				case "FromColumn":
				case "ToColumn":
				case "KPI":
					resolveObject = "value?.MetadataObject";
					break;

			}
        }
		
		return string.Format(@"set {{
				var oldValue = {0};
				if (oldValue{1} == value{1}) return;
				bool undoable = true;
				bool cancel = false;
				OnPropertyChanging(""{0}"", value, ref undoable, ref cancel);
				if (cancel) return;
				MetadataObject.{0} = {4};
				if(undoable) Handler.UndoManager.Add(new UndoPropertyChangedAction(this, ""{0}"", oldValue, value));
				OnPropertyChanged(""{0}"", oldValue, value);{2}{3}
			}}", 
			p.Name, 
			p.PropertyType.IsClass && p.PropertyType != typeof(string) ? "?.MetadataObject" : "",
			p.Name == "DisplayFolder" ? "\n\t\t\t\tHandler.UpdateFolders(Table);" : "",
			p.Name == "IsHidden" ? "\n\t\t\t\tHandler.UpdateObject(this);" : "",
			resolveObject);
    }

	public static string PropertyGetter(PropertyInfo p)
    {
		if(p.PropertyType.IsClass && p.PropertyType != typeof(string)) {
			return string.Format(@"get {{
				if (MetadataObject.{0} == null) return null;
			    return Handler.WrapperLookup[MetadataObject.{0}] as {1};
            }}", p.Name, p.PropertyType.Name);
        } 
		else 
		{
			return string.Format(@"get {{
			    return MetadataObject.{0};
			}}", p.Name);
        };
    }

	public static string SplitCamelCase(string str)
    {
        return Regex.Replace(
            Regex.Replace(
                str,
                @"(\P{Ll})(\P{Ll}\p{Ll})",
                "$1 $2"
            ),
            @"(\p{Ll})(\P{Ll})",
            "$1 $2"
        );
    }

	public static string GetDisplayName(string propertyName, string typeName)
    {
		var result = propertyName;

		if(result.StartsWith("Is") && char.IsUpper(result[2])) result = result.Substring(2);

		if(typeName == "Variation" && propertyName == "Column") return "Parent Column";

		return SplitCamelCase(result);
    }

	public static string GetCategory(string propertyName, string typeName)
    {
		switch(propertyName)
        {
		    case "Perspectives":
			case "Cultures":
				return "Translations and Perspectives";
			case "Roles":
				return "Security";
			case "Partitions":
				return "Data Source";
			case "DisplayFolder":
			case "Name":
			case "IsHidden":
			case "Description":
				return "Basic";
			case "Expression":
			case "SortByColumn":
			case "FormatString":
			case "SourceColumn":
			case "IsPrivate":
			case "ShowAsVariationsOnly":
				return "Options";
			case "Column":
#if CL1400
				if(typeName == "Variation") return "Basic";
#endif
				return "Other";
			case "IsDefault":
			case "DefaultColumn":
			case "DefaultHierarchy":
			case "Relationship":
				return "Variation Options";
			case "DataCategory":
			case "ErrorMessage":
			case "DataType":
			case "State":
				return "Metadata";
			case "FromColumn":
			case "ToColumn":
			case "SecurityFilteringBehavior":
			case "CrossFilteringBehavior":
			case "IsActive":
				return "Relationship";
			default:
				if(typeName == "ProviderDataSource") return "Connection Details";
				if(typeName == "ModelRole") return "Security";
				return "Other";
        }
    }

	public static string GetOtherAttributes(string propertyName, string className)
    {
	    if(className == "Variation" && propertyName == "Column") return "[TypeConverter(typeof(TableColumnConverter)),ReadOnly(true)]";
		if(propertyName == "SortByColumn") return "[TypeConverter(typeof(TableColumnConverter))]";
		if(propertyName == "DefaultColumn") return "[TypeConverter(typeof(AllColumnConverter))]";
		if(propertyName == "DefaultHierarchy") return "[TypeConverter(typeof(AllHierarchyConverter))]";
		if(propertyName == "Relationship") return "[TypeConverter(typeof(AllRelationshipConverter))]";
		if(propertyName == "ToColumn") return "[TypeConverter(typeof(AllColumnConverter))]";
		if(propertyName == "FromColumn") return "[TypeConverter(typeof(AllColumnConverter))]";
		if(className == "Level" && propertyName == "Hierarchy") return "[Browsable(false)]";
		if(className == "Level" && propertyName == "Column") return "[TypeConverter(typeof(HierarchyColumnConverter)),NoMultiselect()]";
		if(className == "Level" && propertyName == "Ordinal") return "[NoMultiselect()]";
		if(className == "Model" && propertyName == "Culture") return "[TypeConverter(typeof(CultureConverter))]";
		if(propertyName.EndsWith("FormatString")) return "[TypeConverter(typeof(FormatStringConverter))]";
		if(propertyName == "DisplayFolder") return "[Editor(typeof(CustomDialogEditor), typeof(System.Drawing.Design.UITypeEditor))]";
		if(propertyName.EndsWith("Expression")) return "[Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]";
		if(propertyName.EndsWith("Description")) return "[Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]";
		if(propertyName == "ContextExpression") return "[Editor(typeof(System.ComponentModel.Design.MultilineStringEditor), typeof(System.Drawing.Design.UITypeEditor))]";
		if(propertyName == "Perspectives") return "[Editor(typeof(TabularEditor.PropertyGridUI.PerspectiveCollectionEditor),typeof(UITypeEditor)),TypeConverter(typeof(StringConverter))]";
		if(propertyName == "Cultures") return "[Editor(typeof(TabularEditor.PropertyGridUI.CultureCollectionEditor),typeof(UITypeEditor)),TypeConverter(typeof(StringConverter))]";
		if(propertyName == "Roles") return "[Editor(typeof(TabularEditor.PropertyGridUI.RefreshGridCollectionEditor), typeof(UITypeEditor)), TypeConverter(typeof(StringConverter))]";
		if(propertyName == "Partitions") return "[NoMultiselect(),Editor(typeof(PartitionCollectionEditor),typeof(UITypeEditor))]";
		if(propertyName == "StatusGraphic") return "[TypeConverter(typeof(KPIStatusGraphicConverter))]";
		if(propertyName == "TrendGraphic") return "[TypeConverter(typeof(KPITrendGraphicConverter))]";
		return "";
    }

	public static readonly Dictionary<Type, string> Aliases = new Dictionary<Type, string>()
	{
		{ typeof(byte), "byte" },
		{ typeof(sbyte), "sbyte" },
		{ typeof(short), "short" },
		{ typeof(ushort), "ushort" },
		{ typeof(int), "int" },
		{ typeof(uint), "uint" },
		{ typeof(long), "long" },
		{ typeof(ulong), "ulong" },
		{ typeof(float), "float" },
		{ typeof(double), "double" },
		{ typeof(decimal), "decimal" },
		{ typeof(object), "object" },
		{ typeof(bool), "bool" },
		{ typeof(char), "char" },
		{ typeof(string), "string" },
		{ typeof(void), "void" }
	};	

	// List of types to generate wrapper for:
	public static readonly Dictionary<Type, string> ObjectTypes = new Dictionary<Type,string>()
	{ 
#if CL1400
	   { typeof(StructuredDataSource), "DataSource" },
       { typeof(Variation), "TabularNamedObject" },
#endif
       { typeof(CalculatedColumn), "Column" },
       { typeof(CalculatedTableColumn), "Column" },
       { typeof(Column), "TabularNamedObject" },
       { typeof(Culture), "TabularNamedObject" },
       { typeof(DataColumn), "Column" },
       { typeof(DataSource), "TabularNamedObject" },
       { typeof(ExternalModelRoleMember), "ModelRoleMember" },
       { typeof(Hierarchy), "TabularNamedObject" },
       { typeof(KPI), "TabularObject" },
       { typeof(Level), "TabularNamedObject" },
       { typeof(Measure), "TabularNamedObject" },
       { typeof(Model), "TabularNamedObject" },
       { typeof(ModelRole), "TabularNamedObject" },
       { typeof(ModelRoleMember), "TabularNamedObject" },
       { typeof(Partition), "TabularNamedObject" },
       { typeof(Perspective), "TabularNamedObject" },
       { typeof(ProviderDataSource), "DataSource" },
       { typeof(Relationship), "TabularNamedObject" },
       { typeof(SingleColumnRelationship), "Relationship" },
       { typeof(Table), "TabularNamedObject" },
       { typeof(WindowsModelRoleMember), "ModelRoleMember" }
   };

   public static readonly Dictionary<Type, string> Collections = new Dictionary<Type,string>()
   {
#if CL1400
       { typeof(Variation), "Variations" },
#endif
       { typeof(ModelRoleMember), "Members" },
       { typeof(ModelRole), "Roles" },
       { typeof(Table), "Tables" },
       { typeof(CalculatedColumn), "Columns" },
       { typeof(CalculatedTableColumn), "Columns" },
       { typeof(DataColumn), "Columns" },
       { typeof(Level), "Levels" },
       { typeof(Hierarchy), "Hierarchies" },
       { typeof(Measure), "Measures" },
       { typeof(Partition), "Partitions" },
       { typeof(Perspective), "Perspectives" },
       { typeof(Culture), "Cultures" },
	   { typeof(Relationship), "Relationships" },
	   { typeof(DataSource), "DataSources" }
   };

   public static string CollectionName(Type itemType) {
	   switch(itemType.Name) {
		   case "ModelRole": return "Roles";
		   case "ModelRoleMember": return "Members";
		   case "Hierarchy": return "Hierarchies";
		   default: return itemType.Name + "s";
       }
   }

   public static readonly List<KeyValuePair<Type, string>> CollectionParent = new List<KeyValuePair<Type, string>>()
   {
	   // Collections owned by a Model (order of items matters, as this is the order in which child objects will be initialized):
       { new KeyValuePair<Type, string>(typeof(Perspective), "Model") },
       { new KeyValuePair<Type, string>(typeof(Culture), "Model") },
	   { new KeyValuePair<Type, string>(typeof(DataSource), "Model") },
       { new KeyValuePair<Type, string>(typeof(ModelRole), "Model") },
       { new KeyValuePair<Type, string>(typeof(Table), "Model") },
	   { new KeyValuePair<Type, string>(typeof(Relationship), "Model") },

	   // Collections owned by a Table (order of items matters, as this is the order in which child objects will be initialized):
       { new KeyValuePair<Type, string>(typeof(Partition), "Table") },
       { new KeyValuePair<Type, string>(typeof(Column), "Table") },
       { new KeyValuePair<Type, string>(typeof(Hierarchy), "Table") },
       { new KeyValuePair<Type, string>(typeof(Measure), "Table") },

	   // Collections owned by a ModelRole (order of items matters, as this is the order in which child objects will be initialized):
       { new KeyValuePair<Type, string>(typeof(ModelRoleMember), "ModelRole") },

#if CL1400
	   // Collections owned by a Column (order of items matters, as this is the order in which child objects will be initialized):
       { new KeyValuePair<Type, string>(typeof(Variation), "Column") },
#endif

	   // Collections owned by a Hierarchy (order of items matters, as this is the order in which child objects will be initialized):
       { new KeyValuePair<Type, string>(typeof(Level), "Hierarchy") }
   };

   private static string ParentOf(Type t) {
	   return Rules.CollectionParent.FirstOrDefault(kvp => kvp.Key == t).Value;
   }

   public static string GetParent(Type t) {
	   return Rules.CollectionParent.Any(kvp => kvp.Key == t) ? 
			ParentOf(t) : ParentOf(t.BaseType);
   }
   public static bool InCollection(Type t) {
	   return Rules.Collections.ContainsKey(t) || Rules.Collections.ContainsKey(t.BaseType);
   }
   public static bool NeedsCollection(Type t) {
	   return Rules.CollectionParent.Any(kvp => kvp.Key == t);
   }
   public static string GetCollection(Type t) {
	   return Rules.Collections.ContainsKey(t) ? 
			Rules.Collections[t] : Rules.Collections[t.BaseType];
   }
   public static bool HasCollections(Type t) {
	   return CollectionParent.Any(c => c.Value == t.Name);
   }
   public static IEnumerable<KeyValuePair<Type, string>> GetChildCollections(Type t) {
	   return Rules.CollectionParent.Where(c => c.Value == t.Name);
   }
}
#>